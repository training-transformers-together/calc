{"version":3,"sources":["streamlit/streamlit.ts","streamlit/ArrowTable.ts","streamlit/StreamlitReact.tsx","Observable.tsx","index.tsx"],"names":["ComponentMessageType","ArrowTable","dataBuffer","indexBuffer","columnsBuffer","styler","dataTable","indexTable","columnsTable","getCell","rowIndex","columnIndex","isBlankCell","headerRows","headerColumns","isIndexCell","isColumnsCell","classNames","push","type","join","content","dataColumnIndex","getContent","dataRowIndex","id","uuid","displayValuesTable","table","column","getColumnAt","getColumnTypeId","Type","Timestamp","nanosToDate","get","this","Table","from","caption","styles","undefined","length","numCols","rows","dataRows","columns","dataColumns","schema","fields","typeId","nanos","Date","Streamlit","API_VERSION","RENDER_EVENT","events","EventTarget","registeredMessageListener","lastFrameHeight","setComponentReady","window","addEventListener","onMessageEvent","sendBackMsg","COMPONENT_READY","apiVersion","setFrameHeight","height","document","body","scrollHeight","SET_FRAME_HEIGHT","setComponentValue","value","SET_COMPONENT_VALUE","event","data","onRenderMessage","args","console","error","dataframeArgs","argsDataframeToObject","eventData","disabled","Boolean","CustomEvent","detail","dispatchEvent","argsDataframe","argsDataframeArrow","map","key","toArrowTable","Object","fromEntries","df","index","parent","postMessage","isStreamlitMessage","StreamlitComponentBase","React","PureComponent","withStreamlitConnection","WrappedComponent","ComponentWrapper","props","componentDidMount","onRenderEvent","componentDidUpdate","prevProps","state","componentError","componentWillUnmount","removeEventListener","renderEvent","setState","renderData","render","message","width","innerWidth","getDerivedStateFromError","hoistNonReactStatics","Observable","observeValue","notebookRef","createRef","runtime","main","style","border","borderRadius","padding","ref","marginTop","backgroundColor","fontWeight","gridTemplateColumns","display","textAlign","name","href","notebook","color","dispose","redefineCells","redefine","targets","observe","hide","a","targetSet","Set","observeSet","hideSet","Runtime","eval","define","default","module","has","fulfilled","size","el","createElement","current","appendChild","i","Inspector","e","pending","rejected","Promise","all","Array","then","initial","cell","embedNotebook","ReactDOM","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.5bdac2e3.chunk.js","sourcesContent":["/**\n * @license\n * Copyright 2018-2020 Streamlit Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Safari doesn't support the EventTarget class, so we use a shim.\nimport { EventTarget } from \"event-target-shim\"\nimport { ArrowDataframeProto, ArrowTable } from \"./ArrowTable\"\n\n/** Data sent in the custom Streamlit render event. */\nexport interface RenderData {\n  args: any\n  disabled: boolean\n}\n\n/** Messages from Component -> Streamlit */\nenum ComponentMessageType {\n  // A component sends this message when it's ready to receive messages\n  // from Streamlit. Streamlit won't send any messages until it gets this.\n  // Data: { apiVersion: number }\n  COMPONENT_READY = \"streamlit:componentReady\",\n\n  // The component has a new widget value. Send it back to Streamlit, which\n  // will then re-run the app.\n  // Data: { value: any }\n  SET_COMPONENT_VALUE = \"streamlit:setComponentValue\",\n\n  // The component has a new height for its iframe.\n  // Data: { height: number }\n  SET_FRAME_HEIGHT = \"streamlit:setFrameHeight\",\n}\n\n/**\n * Streamlit communication API.\n *\n * Components can send data to Streamlit via the functions defined here,\n * and receive data from Streamlit via the `events` property.\n */\nexport class Streamlit {\n  /**\n   * The Streamlit component API version we're targetting.\n   * There's currently only 1!\n   */\n  public static readonly API_VERSION = 1\n\n  public static readonly RENDER_EVENT = \"streamlit:render\"\n\n  /** Dispatches events received from Streamlit. */\n  public static readonly events = new EventTarget()\n\n  private static registeredMessageListener = false\n  private static lastFrameHeight?: number\n\n  /**\n   * Tell Streamlit that the component is ready to start receiving data.\n   * Streamlit will defer emitting RENDER events until it receives the\n   * COMPONENT_READY message.\n   */\n  public static setComponentReady = (): void => {\n    if (!Streamlit.registeredMessageListener) {\n      // Register for message events if we haven't already\n      window.addEventListener(\"message\", Streamlit.onMessageEvent)\n      Streamlit.registeredMessageListener = true\n    }\n\n    Streamlit.sendBackMsg(ComponentMessageType.COMPONENT_READY, {\n      apiVersion: Streamlit.API_VERSION,\n    })\n  }\n\n  /**\n   * Report the component's height to Streamlit.\n   * This should be called every time the component changes its DOM - that is,\n   * when it's first loaded, and any time it updates.\n   */\n  public static setFrameHeight = (height?: number): void => {\n    if (height === undefined) {\n      // `height` is optional. If undefined, it defaults to scrollHeight,\n      // which is the entire height of the element minus its border,\n      // scrollbar, and margin.\n      height = document.body.scrollHeight + 10;\n    }\n\n    if (height === Streamlit.lastFrameHeight) {\n      // Don't bother updating if our height hasn't changed.\n      return\n    }\n\n    Streamlit.lastFrameHeight = height\n    Streamlit.sendBackMsg(ComponentMessageType.SET_FRAME_HEIGHT, { height })\n  }\n\n  /**\n   * Set the component's value. This value will be returned to the Python\n   * script, and the script will be re-run.\n   *\n   * For example:\n   *\n   * JavaScript:\n   * Streamlit.setComponentValue(\"ahoy!\")\n   *\n   * Python:\n   * value = st.my_component(...)\n   * st.write(value) # -> \"ahoy!\"\n   *\n   * The value must be serializable into JSON.\n   */\n  public static setComponentValue = (value: any): void => {\n    Streamlit.sendBackMsg(ComponentMessageType.SET_COMPONENT_VALUE, { value })\n  }\n\n  /** Receive a ForwardMsg from the Streamlit app */\n  private static onMessageEvent = (event: MessageEvent): void => {\n    const type = event.data[\"type\"]\n    switch (type) {\n      case Streamlit.RENDER_EVENT:\n        Streamlit.onRenderMessage(event.data)\n        break\n    }\n  }\n\n  /**\n   * Handle an untyped Streamlit render event and redispatch it as a\n   * StreamlitRenderEvent.\n   */\n  private static onRenderMessage = (data: any): void => {\n    let args = data[\"args\"]\n    if (args == null) {\n      console.error(\n        `Got null args in onRenderMessage. This should never happen`\n      )\n      args = {}\n    }\n\n    // Parse our dataframe arguments with arrow, and merge them into our args dict\n    const dataframeArgs =\n      data[\"dfs\"] && data[\"dfs\"].length > 0\n        ? Streamlit.argsDataframeToObject(data[\"dfs\"])\n        : {}\n\n    args = {\n      ...args,\n      ...dataframeArgs,\n    }\n\n    const disabled = Boolean(data[\"disabled\"])\n\n    // Dispatch a render event!\n    const eventData = { disabled, args }\n    const event = new CustomEvent<RenderData>(Streamlit.RENDER_EVENT, {\n      detail: eventData,\n    })\n    Streamlit.events.dispatchEvent(event)\n  }\n\n  private static argsDataframeToObject = (\n    argsDataframe: ArgsDataframe[]\n  ): object => {\n    const argsDataframeArrow = argsDataframe.map(\n      ({ key, value }: ArgsDataframe) => [key, Streamlit.toArrowTable(value)]\n    )\n    return Object.fromEntries(argsDataframeArrow)\n  }\n\n  private static toArrowTable = (df: ArrowDataframeProto): ArrowTable => {\n    const { data, index, columns } = df.data\n    return new ArrowTable(data, index, columns)\n  }\n\n  /** Post a message to the Streamlit app. */\n  private static sendBackMsg = (type: string, data?: any): void => {\n    window.parent.postMessage(\n      {\n        isStreamlitMessage: true,\n        type: type,\n        ...data,\n      },\n      \"*\"\n    )\n  }\n}\n\ninterface ArgsDataframe {\n  key: string\n  value: ArrowDataframeProto\n}\n","/**\n * @license\n * Copyright 2018-2019 Streamlit Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Table, Type } from \"apache-arrow\"\n\ntype CellType = \"blank\" | \"index\" | \"columns\" | \"data\"\n\nexport interface ArrowDataframeProto {\n  data: ArrowTableProto\n  height: string\n  width: string\n}\n\nexport interface ArrowTableProto {\n  data: Uint8Array\n  index: Uint8Array\n  columns: Uint8Array\n  styler: Styler\n}\n\ninterface Cell {\n  classNames: string\n  content: string\n  id?: string\n  type: CellType\n}\n\ninterface Styler {\n  caption?: string\n  displayValuesTable: Table\n  styles?: string\n  uuid: string\n}\n\nexport class ArrowTable {\n  private readonly dataTable: Table\n  private readonly indexTable: Table\n  private readonly columnsTable: Table\n  private readonly styler?: Styler\n\n  constructor(\n    dataBuffer: Uint8Array,\n    indexBuffer: Uint8Array,\n    columnsBuffer: Uint8Array,\n    styler?: any\n  ) {\n    this.dataTable = Table.from(dataBuffer)\n    this.indexTable = Table.from(indexBuffer)\n    this.columnsTable = Table.from(columnsBuffer)\n    this.styler = styler\n      ? {\n          caption: styler.get(\"caption\"),\n          displayValuesTable: Table.from(styler.get(\"displayValues\")),\n          styles: styler.get(\"styles\"),\n          uuid: styler.get(\"uuid\"),\n        }\n      : undefined\n  }\n\n  get rows(): number {\n    return this.indexTable.length + this.columnsTable.numCols\n  }\n\n  get columns(): number {\n    return this.indexTable.numCols + this.columnsTable.length\n  }\n\n  get headerRows(): number {\n    return this.rows - this.dataRows\n  }\n\n  get headerColumns(): number {\n    return this.columns - this.dataColumns\n  }\n\n  get dataRows(): number {\n    return this.dataTable.length\n  }\n\n  get dataColumns(): number {\n    return this.dataTable.numCols\n  }\n\n  get uuid(): string | undefined {\n    return this.styler && this.styler.uuid\n  }\n\n  get caption(): string | undefined {\n    return this.styler && this.styler.caption\n  }\n\n  get styles(): string | undefined {\n    return this.styler && this.styler.styles\n  }\n\n  get table(): Table {\n    return this.dataTable\n  }\n\n  get index(): Table {\n    return this.indexTable\n  }\n\n  get columnTable(): Table {\n    return this.columnsTable\n  }\n\n  public getCell = (rowIndex: number, columnIndex: number): Cell => {\n    const isBlankCell =\n      rowIndex < this.headerRows && columnIndex < this.headerColumns\n    const isIndexCell =\n      rowIndex >= this.headerRows && columnIndex < this.headerColumns\n    const isColumnsCell =\n      rowIndex < this.headerRows && columnIndex >= this.headerColumns\n\n    if (isBlankCell) {\n      const classNames = [\"blank\"]\n      if (columnIndex > 0) {\n        classNames.push(\"level\" + rowIndex)\n      }\n\n      return {\n        type: \"blank\",\n        classNames: classNames.join(\" \"),\n        content: \"\",\n      }\n    } else if (isColumnsCell) {\n      const dataColumnIndex = columnIndex - this.headerColumns\n      const classNames = [\n        \"col_heading\",\n        \"level\" + rowIndex,\n        \"col\" + dataColumnIndex,\n      ]\n\n      return {\n        type: \"columns\",\n        classNames: classNames.join(\" \"),\n        content: this.getContent(this.columnsTable, dataColumnIndex, rowIndex),\n      }\n    } else if (isIndexCell) {\n      const dataRowIndex = rowIndex - this.headerRows\n      const classNames = [\n        \"row_heading\",\n        \"level\" + columnIndex,\n        \"row\" + dataRowIndex,\n      ]\n\n      return {\n        type: \"index\",\n        id: `T_${this.uuid}level${columnIndex}_row${dataRowIndex}`,\n        classNames: classNames.join(\" \"),\n        content: this.getContent(this.indexTable, dataRowIndex, columnIndex),\n      }\n    } else {\n      const dataRowIndex = rowIndex - this.headerRows\n      const dataColumnIndex = columnIndex - this.headerColumns\n      const classNames = [\n        \"data\",\n        \"row\" + dataRowIndex,\n        \"col\" + dataColumnIndex,\n      ]\n      const content = this.styler\n        ? this.getContent(\n            this.styler.displayValuesTable,\n            dataRowIndex,\n            dataColumnIndex\n          )\n        : this.getContent(this.dataTable, dataRowIndex, dataColumnIndex)\n\n      return {\n        type: \"data\",\n        id: `T_${this.uuid}row${dataRowIndex}_col${dataColumnIndex}`,\n        classNames: classNames.join(\" \"),\n        content,\n      }\n    }\n  }\n\n  public getContent = (\n    table: Table,\n    rowIndex: number,\n    columnIndex: number\n  ): any => {\n    const column = table.getColumnAt(columnIndex)\n    if (column === null) {\n      return \"\"\n    }\n\n    const columnTypeId = this.getColumnTypeId(table, columnIndex)\n    switch (columnTypeId) {\n      case Type.Timestamp: {\n        return this.nanosToDate(column.get(rowIndex))\n      }\n      default: {\n        return column.get(rowIndex)\n      }\n    }\n  }\n\n  /**\n   * Returns apache-arrow specific typeId of column.\n   */\n  private getColumnTypeId(table: Table, columnIndex: number): Type {\n    return table.schema.fields[columnIndex].type.typeId\n  }\n\n  private nanosToDate(nanos: number): Date {\n    return new Date(nanos / 1e6)\n  }\n}\n","import hoistNonReactStatics from \"hoist-non-react-statics\"\nimport React, { ReactNode } from \"react\"\nimport { RenderData, Streamlit } from \"./streamlit\"\n\n/**\n * Props passed to custom Streamlit components.\n */\nexport interface ComponentProps {\n  /** Named dictionary of arguments passed from Python. */\n  args: any\n\n  /** The component's width. */\n  width: number\n\n  /**\n   * True if the component should be disabled.\n   * All components get disabled while the app is being re-run,\n   * and become re-enabled when the re-run has finished.\n   */\n  disabled: boolean\n}\n\n/**\n * Optional Streamlit React-based component base class.\n *\n * You are not required to extend this base class to create a Streamlit\n * component. If you decide not to extend it, you should implement the\n * `componentDidMount` and `componentDidUpdate` functions in your own class,\n * so that your plugin properly resizes.\n */\nexport class StreamlitComponentBase<S = {}> extends React.PureComponent<\n  ComponentProps,\n  S\n  > {\n  public componentDidMount(): void {\n    // After we're rendered for the first time, tell Streamlit that our height\n    // has changed.\n    Streamlit.setFrameHeight()\n  }\n\n  public componentDidUpdate(): void {\n    // After we're updated, tell Streamlit that our height may have changed.\n    Streamlit.setFrameHeight()\n  }\n}\n\n/**\n * Wrapper for React-based Streamlit components.\n *\n * Bootstraps the communication interface between Streamlit and the component.\n */\nexport function withStreamlitConnection(\n  WrappedComponent: React.ComponentType<ComponentProps>\n): React.ComponentType {\n  interface WrapperProps { }\n\n  interface WrapperState {\n    renderData?: RenderData\n    componentError?: Error\n  }\n\n  class ComponentWrapper extends React.PureComponent<\n    WrapperProps,\n    WrapperState\n    > {\n    public constructor(props: WrapperProps) {\n      super(props)\n      this.state = {\n        renderData: undefined,\n        componentError: undefined,\n      }\n    }\n\n    /**\n     * Error boundary function. This will be called if our wrapped\n     * component throws an error. We store the caught error in our state,\n     * and display it in the next render().\n     */\n    public static getDerivedStateFromError = (\n      error: Error\n    ): Partial<WrapperState> => {\n      return { componentError: error }\n    }\n\n    public componentDidMount = (): void => {\n      // Set up event listeners, and signal to Streamlit that we're ready.\n      // We won't render the component until we receive the first RENDER_EVENT.\n      Streamlit.events.addEventListener(\n        Streamlit.RENDER_EVENT,\n        this.onRenderEvent\n      )\n      Streamlit.setComponentReady()\n    }\n\n    public componentDidUpdate = (prevProps: any): void => {\n      // If our child threw an error, we display it in render(). In this\n      // case, the child won't be mounted and therefore won't call\n      // `setFrameHeight` on its own. We do it here so that the rendered\n      // error will be visible.\n      if (this.state.componentError != null) {\n        Streamlit.setFrameHeight()\n      }\n    }\n\n    public componentWillUnmount = (): void => {\n      Streamlit.events.removeEventListener(\n        Streamlit.RENDER_EVENT,\n        this.onRenderEvent\n      )\n    }\n\n    /**\n     * Streamlit is telling this component to redraw.\n     * We save the render data in State, so that it can be passed to the\n     * component in our own render() function.\n     */\n    private onRenderEvent = (event: Event): void => {\n      // Update our state with the newest render data\n      const renderEvent = event as CustomEvent<RenderData>\n      this.setState({ renderData: renderEvent.detail })\n    }\n\n    public render = (): ReactNode => {\n      // If our wrapped component threw an error, display it.\n      if (this.state.componentError != null) {\n        return (\n          <div>\n            <h1>Component Error</h1>\n            <span>{this.state.componentError.message}</span>\n          </div>\n        )\n      }\n\n      // Don't render until we've gotten our first RENDER_EVENT from Streamlit.\n      if (this.state.renderData == null) {\n        return null\n      }\n\n      return (\n        <WrappedComponent\n          width={window.innerWidth}\n          disabled={this.state.renderData.disabled}\n          args={this.state.renderData.args}\n        />\n      )\n    }\n  }\n\n  return hoistNonReactStatics(ComponentWrapper, WrappedComponent)\n}\n","import React, { ReactNode } from \"react\"\nimport {\n  withStreamlitConnection,\n  StreamlitComponentBase,\n  Streamlit,\n} from \"./streamlit\"\nimport { Runtime, Inspector } from \"@observablehq/runtime\";\n\nclass Observable extends StreamlitComponentBase<{}> {\n  public observeValue = {};\n  private notebookRef = React.createRef<HTMLDivElement>();\n  private runtime: any = null;\n  private main: any = null;\n\n  componentWillUnmount() {\n    this.runtime?.dispose();\n  }\n  // @ts-ignore\n  public componentDidUpdate(prevProps: any) {\n    const { args: prevArgs } = prevProps;\n    if (prevArgs.notebook !== this.props.args.notebook) {\n      // TODO handle new notebook\n    }\n    this.redefineCells(this.main, this.props.args.redefine);\n  }\n\n  async embedNotebook(notebook: string, targets: string[], observe: string[], hide:string[]) {\n    if (this.runtime) {\n      this.runtime.dispose();\n    }\n    const targetSet = new Set(targets);\n    const observeSet = new Set(observe);\n    const hideSet = new Set(hide);\n    this.runtime = new Runtime();\n    const { default: define } = await eval(`import(\"https://api.observablehq.com/${notebook}.js?v=3\")`);\n    this.main = this.runtime.module(define, (name: string) => {\n      if (observeSet.has(name) && !targetSet.has(name)) {\n        const observeValue = this.observeValue;\n        return {\n          fulfilled: (value: any) => {\n            //@ts-ignore\n            observeValue[name] = value;\n            //@ts-ignore\n            Streamlit.setComponentValue(observeValue);\n          }\n        }\n      }\n      if (targetSet.size > 0 && !targetSet.has(name)) return;\n      if(hideSet.has(name)) return true;\n      const el = document.createElement('div');\n      this.notebookRef.current?.appendChild(el);\n\n      const i = new Inspector(el);\n      el.addEventListener('input', e => {\n        Streamlit.setFrameHeight();\n      })\n      return {\n        pending() {\n          i.pending();\n          Streamlit.setFrameHeight();\n        },\n        fulfilled(value: any) {\n          i.fulfilled(value);\n          Streamlit.setFrameHeight();\n        },\n        rejected(error: any) {\n          i.rejected(error);\n          Streamlit.setFrameHeight();\n        },\n      };\n    });\n    if (observeSet.size > 0) {\n      Promise.all(Array.from(observeSet).map(async name => [name, await this.main.value(name)])).then(initial => {\n        for (const [name, value] of initial) {\n          // @ts-ignore\n          this.observeValue[name] = value\n        };\n        Streamlit.setComponentValue(this.observeValue);\n      })\n    }\n  }\n\n  redefineCells(main: any, redefine = {}) {\n    for (let cell in redefine) {\n      //@ts-ignore\n      main.redefine(cell, redefine[cell]);\n    }\n  }\n  componentDidMount() {\n    const { notebook, targets = [], observe = [], redefine = {} , hide=[]} = this.props.args;\n    Streamlit.setComponentValue(this.observeValue);\n    this.embedNotebook(notebook, targets, observe, hide).then(() => {\n      this.redefineCells(this.main, redefine);\n    });\n\n  }\n\n  public render = (): ReactNode => {\n    return (\n      <div style={{ border: '1px solid gray', borderRadius: '4px' }}>\n        <div style={{ padding: '9px 12px' }}>\n          <div ref={this.notebookRef}></div>\n        </div>\n        <div style={{ marginTop: '4px' }}>\n          \n          <div style={{\n            backgroundColor: '#ddd',\n            fontWeight: 700,\n            padding: \".25rem .5rem\",\n            borderRadius: '0 0 4px 4px',\n            gridTemplateColumns: \"auto auto\",\n            display:\"grid\"\n          }}>\n            <div style={{textAlign:\"left\"}}>{this.props.args.name}</div>\n            <div style={{textAlign:\"right\"}}>\n            <a href={`https://observablehq.com/${this.props.args.notebook}`} style={{ color: '#666', }}></a>\n            </div>\n          </div>\n        </div>\n      </div >\n    )\n  }\n}\n\nexport default withStreamlitConnection(Observable)\n","import React from \"react\"\nimport ReactDOM from \"react-dom\"\nimport Observable from \"./Observable\"\n\nReactDOM.render(\n  <React.StrictMode>\n    <Observable />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n)\n"],"sourceRoot":""}